{{short description|Vector quantization algorithm minimizing the sum of squared deviations}}
{{Machine learning bar}}'''''k''-means clustering''' is a method of [[vector quantization]], originally from [[signal processing]], that is popular for [[cluster analysis]] in [[data mining]]. ''k''-means clustering aims to [[Partition of a set|partition]] ''n'' observations into ''k'' clusters in which each observation belongs to the [[Cluster (statistics)|cluster]] with the nearest [[mean]], serving as a prototype of the cluster. This results in a partitioning of the data space into [[Voronoi cell|Voronoi cells]].

The problem is computationally difficult ([[NP-hardness|NP-hard]]); however, efficient [[Heuristic algorithm|heuristic algorithms]] converge quickly to a [[local optimum]]. These are usually similar to the [[expectation-maximization algorithm]] for [[Mixture model|mixtures]] of [[Gaussian distribution|Gaussian distributions]] via an iterative refinement approach employed by both ''k-means'' and ''Gaussian mixture modeling''. They both use cluster centers to model the data; however, ''k''-means clustering tends to find clusters of comparable spatial extent, while the expectation-maximization mechanism allows clusters to have different shapes.

The algorithm has a loose relationship to the [[K-nearest neighbor|''k''-nearest neighbor classifier]], a popular [[machine learning]] technique for classification that is often confused with ''k''-means due to the name. Applying the 1-nearest neighbor classifier to the cluster centers obtained by ''k''-means classifies new data into the existing clusters. This is known as [[nearest centroid classifier]] or [[Rocchio algorithm]].

== Description ==
Given a set of observations ('''x'''<sub>1</sub>, '''x'''<sub>2</sub>, …, '''x'''<sub>''n''</sub>), where each observation is a ''d''-dimensional real vector, ''k''-means clustering aims to partition the ''n'' observations into ''k'' (= ''n'') sets '''S'''&nbsp;=&nbsp;{''S''<sub>1</sub>,&nbsp;''S''<sub>2</sub>,&nbsp;…,&nbsp;''S<sub>k</sub>''} so as to minimize the within-cluster sum of squares (WCSS) (i.e. [[variance]]). Formally, the objective is to find:<center><math>\underset{\mathbf{S}} {\operatorname{arg\,min}}  \sum_{i=1}^{k} \sum_{\mathbf x \in S_i} \left\| \mathbf x - \boldsymbol\mu_i \right\|^2 = \underset{\mathbf{S}} {\operatorname{arg\,min}}  \sum_{i=1}^{k} |S_i| \operatorname{Var} S_i </math></center>where '''''µ'''<sub>i</sub>'' is the mean of points in ''S<sub>i</sub>''. This is equivalent to minimizing the pairwise squared deviations of points in the same cluster:<center><math>\underset{\mathbf{S}} {\operatorname{arg\,min}}  \sum_{i=1}^{k} \, \frac{1}{2 |S_i|} \, \sum_{\mathbf{x}, \mathbf{y} \in S_i} \left\| \mathbf{x} - \mathbf{y} \right\|^2</math></center>The equivalence can be deduced from identity <math>\sum_{\mathbf x \in S_i} \left\| \mathbf x - \boldsymbol\mu_i \right\|^2 =\sum_{\mathbf{x}\neq\mathbf{y} \in S_i}(\mathbf x - \boldsymbol\mu_i)(\boldsymbol\mu_i - \mathbf y)</math>. Because the total variance is constant, this is equivalent to maximizing the sum of squared deviations between points in ''different'' clusters (between-cluster sum of squares, BCSS),<ref name=":12">{{cite journal|last1=Kriegel|first1=Hans-Peter|authorlink=Hans-Peter Kriegel|last2=Schubert|first2=Erich|last3=Zimek|first3=Arthur|authorlink3=Arthur Zimek|year=2016|title=The (black) art of runtime evaluation: Are we comparing algorithms or implementations?|journal=Knowledge and Information Systems|volume=52|issue=2|pages=341–378|doi=10.1007/s10115-016-1004-2|issn=0219-1377}}</ref> which follows from the [[law of total variance]].

== History ==
The term "''k''-means" was first used by James MacQueen in 1967,<ref name="macqueen19672">{{cite conference|last=MacQueen|first=J. B.|year=1967|title=Some Methods for classification and Analysis of Multivariate Observations|url=http://projecteuclid.org/euclid.bsmsp/1200512992|conference=Proceedings of 5th Berkeley Symposium on Mathematical Statistics and Probability|publisher=University of California Press|volume=1|pages=281&ndash;297|mr=0214227|zbl=0214.46201|accessdate=2009-04-07}}</ref> though the idea goes back to [[Hugo Steinhaus]] in 1957.<ref>{{cite journal|last=Steinhaus|first=H.|authorlink=Hugo Steinhaus|year=1957|title=Sur la division des corps matériels en parties|journal=Bull. Acad. Polon. Sci.|language=French|volume=4|issue=12|pages=801&ndash;804|mr=0090073|zbl=0079.16403}}</ref> The standard algorithm was first proposed by Stuart Lloyd in 1957 as a technique for [[pulse-code modulation]], though it wasn't published outside of [[Bell Labs]] until 1982.<ref name="lloyd19572">{{cite journal|last=Lloyd|first=S. P.|year=1957|title=Least square quantization in PCM|journal=Bell Telephone Laboratories Paper}} Published in journal much later: {{cite journal|last=Lloyd.|first=S. P.|year=1982|title=Least squares quantization in PCM|url=http://www.cs.toronto.edu/~roweis/csc2515-2006/readings/lloyd57.pdf|journal=[[IEEE Transactions on Information Theory]]|volume=28|issue=2|pages=129&ndash;137|doi=10.1109/TIT.1982.1056489|accessdate=2009-04-15|citeseerx=10.1.1.131.1338}}</ref> In 1965, E. W. Forgy published essentially the same method, which is why it is sometimes referred to as Lloyd-Forgy.<ref name="forgy652">{{Cite journal|author=E.W. Forgy|year=1965|title=Cluster analysis of multivariate data: efficiency versus interpretability of classifications|journal=Biometrics|volume=21|issue=3|pages=768–769|jstor=2528559}}</ref>

== Algorithms ==
=== Standard algorithm ===
[[File:K-means_convergence.gif|right|thumb|Convergence of ''k''-means]]
The most common algorithm uses an iterative refinement technique. Due to its ubiquity it is often called the ''k''-means algorithm; it is also referred to as [[Lloyd's algorithm]], particularly in the computer science community.

Given an initial set of ''k'' means ''m''<sub>1</sub><sup>(1)</sup>,…,''m<sub>k</sub>''<sup>(1)</sup> (see below), the algorithm proceeds by alternating between two steps:<ref>{{Cite book|url=http://www.inference.phy.cam.ac.uk/mackay/itila/book.html|title=Information Theory, Inference and Learning Algorithms|last=MacKay|first=David|publisher=Cambridge University Press|year=2003|isbn=978-0-521-64298-9|pages=284&ndash;292|chapter=Chapter 20. An Example Inference Task: Clustering|mr=2012999|ref=mackay2003|authorlink=David MacKay (scientist)|chapterurl=http://www.inference.phy.cam.ac.uk/mackay/itprnn/ps/284.292.pdf}}</ref>

: Assignment step: Assign each observation to the cluster whose mean has the least squared [[Euclidean distance]], this is intuitively the "nearest" mean.<ref>Since the square root is a monotone function, this also is the minimum Euclidean distance assignment.</ref> (Mathematically, this means partitioning the observations according to the [[Voronoi diagram]] generated by the means).
:: <math>S_i^{(t)} = \big \{ x_p : \big \| x_p - m^{(t)}_i \big \|^2 \le \big \| x_p - m^{(t)}_j \big \|^2 \ \forall j, 1 \le j \le k \big\},</math>
:: where each <math>x_p</math> is assigned to exactly one <math>S^{(t)}</math>, even if it could be assigned to two or more of them.
: Update step: Calculate the new means to be the [[centroids]] of the observations in the new clusters.
:: <math>m^{(t+1)}_i = \frac{1}{|S^{(t)}_i|} \sum_{x_j \in S^{(t)}_i} x_j </math>

The algorithm has converged when the assignments no longer change. The algorithm does not guarantee to find the optimum.<ref name="hartigan19792">{{Cite journal|last1=Hartigan|first1=J. A.|last2=Wong|first2=M. A.|year=1979|title=Algorithm AS 136: A ''k''-Means Clustering Algorithm|journal=[[Journal of the Royal Statistical Society, Series C]]|volume=28|issue=1|pages=100&ndash;108|jstor=2346830}}</ref>

The algorithm is often presented as assigning objects to the nearest cluster by distance. Using a different distance function other than (squared) Euclidean distance may stop the algorithm from converging. Various modifications of ''k''-means such as spherical ''k''-means and [[K-medoids|''k''-medoids]] have been proposed to allow using other distance measures.

====Initialization methods====
Commonly used initialization methods are Forgy and Random Partition.<ref name="hamerly4">{{Cite conference|author1=Hamerly, G.|author2=Elkan, C.|year=2002|title=Alternatives to the ''k''-means algorithm that find better clusterings|url=http://people.csail.mit.edu/tieu/notebook/kmeans/15_p600-hamerly.pdf|booktitle=Proceedings of the eleventh international conference on Information and knowledge management (CIKM)}}</ref> The Forgy method randomly chooses ''k'' observations from the dataset and uses these as the initial means. The Random Partition method first randomly assigns a cluster to each observation and then proceeds to the update step, thus computing the initial mean to be the centroid of the cluster's randomly assigned points. The Forgy method tends to spread the initial means out, while Random Partition places all of them close to the center of the data set. According to Hamerly et al.,<ref name="hamerly4" /> the Random Partition method is generally preferable for algorithms such as the ''k''-harmonic means and fuzzy ''k''-means. For expectation maximization and standard ''k''-means algorithms, the Forgy method of initialization is preferable. A comprehensive study by Celebi et al.,<ref>{{cite journal|author=Celebi, M. E., Kingravi, H. A., and Vela, P. A.|year=2013|title=A comparative study of efficient initialization methods for the ''k''-means clustering algorithm|journal=[[Expert Systems with Applications]]|volume=40|issue=1|pages=200&ndash;210|arxiv=1209.1960|doi=10.1016/j.eswa.2012.07.021}}</ref> however, found that popular initialization methods such as Forgy, Random Partition, and Maximin often perform poorly, whereas Bradley and Fayyad's approach<ref>{{Cite conference|last1=Bradley|first1=Paul S.|last2=Fayyad|first2=Usama M.|author-link2=Usama Fayyad|year=1998|title=Refining Initial Points for ''k''-Means Clustering|book-title=Proceedings of the Fifteenth International Conference on Machine Learning}}</ref> performs "consistently" in "the best group" and [[K-means++|''k''-means++]] performs "generally well".<gallery caption="Demonstration of the standard algorithm" widths="150px">
Image:K Means Example Step 1.svg|1. ''k'' initial "means" (in this case ''k''=3) are randomly generated within the data domain (shown in color).
Image:K Means Example Step 2.svg|2. ''k'' clusters are created by associating every observation with the nearest mean. The partitions here represent the [[Voronoi diagram]] generated by the means.
Image:K Means Example Step 3.svg|3. The [[centroid]] of each of the ''k'' clusters becomes the new mean.
Image:K Means Example Step 4.svg|4. Steps 2 and 3 are repeated until convergence has been reached.
</gallery>The algorithm does not guarantee convergence to the global optimum. The result may depend on the initial clusters. As the algorithm is usually fast, it is common to run it multiple times with different starting conditions. However, worst case performance can be slow: in particular certain point sets, even in 2 dimensions, converge in exponential time, that is {{math|2<sup>O(<var>n</var>)</sup>}}.<ref>{{cite journal|last=Vattani.|first=A.|year=2011|title=k-means requires exponentially many iterations even in the plane|url=http://cseweb.ucsd.edu/users/avattani/papers/kmeans-journal.pdf|journal=[[Discrete and Computational Geometry]]|volume=45|issue=4|pages=596&ndash;616|doi=10.1007/s00454-011-9340-1}}</ref> These point sets do not seem to arise in practice: this is corroborated by the fact that the [[Smoothed analysis|smoothed]] running time of ''k''-means is polynomial.<ref name="Arthur, D.; Manthey, B.; Roeglin, H. 20092">{{cite conference|author1=Arthur, D.|author2=Manthey, B.|author3=Roeglin, H.|year=2009|title=k-means has polynomial smoothed complexity|booktitle=Proceedings of the 50th Symposium on Foundations of Computer Science (FOCS)|arxiv=0904.1113}}</ref>

The "assignment" step is referred to as the "expectation step", while the "update step" is a maximization step, making this algorithm a variant of the ''generalized'' [[expectation-maximization algorithm]].

=== Complexity ===
Finding the optimal solution to the ''k''-means clustering problem for observations in ''d'' dimensions is:

* [[NP-hard]] in general Euclidean space ''d'' even for 2 clusters,<ref>{{Cite journal|last=Garey|first=M.|last2=Johnson|first2=D.|last3=Witsenhausen|first3=H.|date=1982-03-01|title=The complexity of the generalized Lloyd - Max problem (Corresp.)|url=http://ieeexplore.ieee.org/document/1056488/|journal=IEEE Transactions on Information Theory|volume=28|issue=2|pages=255–256|doi=10.1109/TIT.1982.1056488|issn=0018-9448}}</ref><ref>{{Cite journal|last=Kleinberg|first=Jon|last2=Papadimitriou|first2=Christos|last3=Raghavan|first3=Prabhakar|date=1998-12-01|title=A Microeconomic View of Data Mining|journal=Data Mining and Knowledge Discovery|language=en|volume=2|issue=4|pages=311–324|doi=10.1023/A:1009726428407|issn=1384-5810}}</ref><ref>{{cite journal|author1=Aloise, D.|author2=Deshpande, A.|author3=Hansen, P.|author4=Popat, P.|year=2009|title=NP-hardness of Euclidean sum-of-squares clustering|journal=[[Machine Learning (journal)|Machine Learning]]|volume=75|issue=2|pages=245&ndash;249|doi=10.1007/s10994-009-5103-0}}</ref><ref>{{cite journal|author1=Dasgupta, S.|author2=Freund, Y.|date=July 2009|title=Random Projection Trees for Vector Quantization|journal=Information Theory, IEEE Transactions on|volume=55|issue=7|pages=3229&ndash;3242|arxiv=0805.1390|doi=10.1109/TIT.2009.2021326}}</ref>
* [[NP-hard]] for a general number of clusters ''k'' even in the plane,<ref>{{cite book|author1=Mahajan, M.|author2=Nimbhorkar, P.|author3=Varadarajan, K.|year=2009|title=The Planar ''k''-Means Problem is NP-Hard|series=Lecture Notes in Computer Science|volume=5431|pages=274&ndash;285|doi=10.1007/978-3-642-00202-1_24|isbn=978-3-642-00201-4|citeseerx=10.1.1.331.1306}}</ref>
* if ''k'' and ''d'' (the dimension) are fixed, the problem can be exactly solved in time <math>O(n^{dk+1})</math>, where ''n'' is the number of entities to be clustered.<ref>{{cite conference|author1=Inaba, M.|author2=Katoh, N.|author3=Imai, H.|year=1994|title=Applications of weighted Voronoi diagrams and randomization to variance-based ''k''-clustering|conference=[[Symposium on Computational Geometry|Proceedings of 10th ACM Symposium on Computational Geometry]]|pages=332&ndash;339|doi=10.1145/177424.178042}}</ref>

Thus, a variety of [[Heuristic algorithm|heuristic algorithms]] such as Lloyd's algorithm given above are generally used.

The running time of Lloyd's algorithm (and most variants) is <math>O(n k d i)</math>,<ref name="hartigan19792" /><ref>{{Cite book|title=Introduction to information retrieval|last=D.|first=Manning, Christopher|date=2008|publisher=Cambridge University Press|others=Raghavan, Prabhakar., Schütze, Hinrich.|isbn=978-0521865715|location=New York|oclc=190786122}}</ref> where:
* ''n'' is the number of ''d''-dimensional vectors
* ''k'' the number of clusters
* ''i'' the number of iterations needed until convergence.

On data that does have a clustering structure, the number of iterations until convergence is often small, and results only improve slightly after the first dozen iterations. Lloyd's algorithm is therefore often considered to be of "linear" complexity in practice, although it is in the [[Worst-case complexity|worst case]] superpolynomial when performed until convergence.<ref name=":02">{{Cite book|last=Arthur|first=David|last2=Vassilvitskii|first2=Sergei|date=2006-01-01|title=How Slow is the ''k''-means Method?|journal=Proceedings of the Twenty-second Annual Symposium on Computational Geometry|series=SCG '06|location=New York, NY, USA|publisher=ACM|pages=144–153|doi=10.1145/1137856.1137880|isbn=978-1595933409}}</ref>

* In the worst-case, Lloyd's algorithm needs <math>i=2^{\Omega(\sqrt{n})}</math> iterations, so that the worst-case complexity of Lloyd's algorithm is [[Time complexity#Superpolynomial time|superpolynomial]].<ref name=":02" />
* Lloyd's ''k''-means algorithm has polynomial smoothed running time. It is shown that<ref name="Arthur, D.; Manthey, B.; Roeglin, H. 20092" /> for arbitrary set of ''n'' points in <math>[0,1]^d</math>, if each point is independently perturbed by a normal distribution with mean {{math|0}} and variance <math>\sigma^2</math>, then the expected running time of {{mvar|k}}-means algorithm is bounded by <math>O( n^{34}k^{34}d^8 \log^4(n)/ \sigma^6 )</math>, which is a polynomial in {{mvar|n}}, {{mvar|k}}, {{mvar|d}} and <math>1/\sigma</math>.
* Better bounds are proven for simple cases. For example, in <ref>{{Cite thesis|author1=Arthur|title=A theoretical analysis of Lloyd's algorithm for ''k''-means clustering|url=https://gautam5.cse.iitk.ac.in/opencs/sites/default/files/final.pdf|author2=Abhishek Bhowmick|year=2009|deadurl=yes|archiveurl=https://web.archive.org/web/20151208140946/https://gautam5.cse.iitk.ac.in/opencs/sites/default/files/final.pdf|archivedate=2015-12-08|df=}}</ref> it is shown that the running time of ''k''-means algorithm is bounded by <math>O(dn^4M^2)</math> for {{mvar|n}} points in an [[integer lattice]] <math>\{1,\dots, M\}^d</math>.

Lloyd's algorithm is the standard approach for this problem. However, it spends a lot of processing time computing the distances between each of the k cluster centers and the n data points. Since points usually stay in the same clusters after a few iterations, much of this work is unnecessary, making the naive implementation very inefficient. Some implementations use caching and the triangle inequality in order to create bounds and accelerate Lloyd's algorithm.<ref name="hartigan19792" /><ref name="phillips2">{{Cite book|title=Acceleration of ''k''-Means and Related Clustering Algorithms|volume = 2409|last=Phillips|first=Steven J.|date=2002-01-04|publisher=Springer Berlin Heidelberg|isbn=978-3-540-43977-6|editor-last=Mount|editor-first=David M.|series=Lecture Notes in Computer Science|pages=166–177|doi=10.1007/3-540-45643-0_13|editor-last2=Stein|editor-first2=Clifford|chapter = Acceleration of K-Means and Related Clustering Algorithms}}</ref><ref name="elkan2">{{Cite conference|author=Elkan, C.|year=2003|title=Using the triangle inequality to accelerate ''k''-means|url=http://www-cse.ucsd.edu/~elkan/kmeansicml03.pdf|booktitle=Proceedings of the Twentieth International Conference on Machine Learning (ICML)}}</ref><ref name="hamerly22">{{Cite journal|title=Making ''k''-means even faster|last=Hamerly|first=Greg|citeseerx = 10.1.1.187.3017}}</ref><ref name="hamerly32">{{cite book|last1=Hamerly|first1=Greg|last2=Drake|first2=Jonathan|date=2015|title=Accelerating Lloyd's algorithm for ''k''-means clustering|journal=Partitional Clustering Algorithms|pages=41–78|doi=10.1007/978-3-319-09259-1_2|isbn=978-3-319-09258-4}}</ref>

=== Variations ===

* [[Jenks natural breaks optimization]]: ''k''-means applied to univariate data
* [[K-medians clustering|''k''-medians clustering]] uses the median in each dimension instead of the mean, and this way minimizes <math>L_1</math> norm ([[Taxicab geometry]]).
* [[K-medoids|''k''-medoids]] (also: Partitioning Around Medoids, PAM) uses the medoid instead of the mean, and this way minimizes the sum of distances for ''arbitrary'' distance functions.
* [[Fuzzy clustering#Fuzzy c-means clustering|Fuzzy C-Means Clustering]] is a soft version of ''k''-means, where each data point has a fuzzy degree of belonging to each cluster.
* [[Mixture model#Gaussian mixture model|Gaussian mixture]] models trained with [[expectation-maximization algorithm]] (EM algorithm) maintains probabilistic assignments to clusters, instead of deterministic assignments, and multivariate Gaussian distributions instead of means.
* [[K-means++|''k''-means++]] chooses initial centers in a way that gives a provable upper bound on the WCSS objective.
* HG-means is a sophisticated extension of K-means which escapes from local minima through iterative recombination steps and K-means improvement phases<ref>{{cite journal|author=Gribel, D. and Vidal, T.|year=2019|title=HG-means: A scalable hybrid metaheuristic for minimum sum-of-squares clustering|journal=[[Pattern Recognition]]|volume=88|issue=1|pages=569&ndash;583|arxiv=1804.09813|doi=10.1016/j.patcog.2018.12.022}}</ref>
* The filtering algorithm uses [[Kd-tree|kd-trees]] to speed up each ''k''-means step.<ref>{{cite journal|author=Kanungo, T.; [[David Mount|Mount, D. M.]]; [[Nathan Netanyahu|Netanyahu, N. S.]]; Piatko, C. D.; Silverman, R.; Wu, A. Y.|year=2002|title=An efficient ''k''-means clustering algorithm: Analysis and implementation|url=http://www.cs.umd.edu/~mount/Papers/pami02.pdf|journal=IEEE Transactions on Pattern Analysis and Machine Intelligence|volume=24|issue=7|pages=881&ndash;892|doi=10.1109/TPAMI.2002.1017616|accessdate=2009-04-24}}</ref>
* Some methods attempt to speed up each ''k''-means step using the [[triangle inequality]].<ref name="phillips2" /><ref name="elkan2" /><ref name="hamerly22" /><ref>{{Cite journal|last=Drake|first=Jonathan|date=2012|title=Accelerated ''k''-means with adaptive distance bounds|url=http://opt.kyb.tuebingen.mpg.de/papers/opt2012_paper_13.pdf|journal=The 5th NIPS Workshop on Optimization for Machine Learning, OPT2012|doi=|pmid=|access-date=}}</ref><ref name="hamerly32" />
* Escape local optima by swapping points between clusters.<ref name="hartigan19792" />
* The Spherical ''k''-means clustering algorithm is suitable for textual data.<ref>{{Cite journal|last1=Dhillon|first1=I. S.|last2=Modha|first2=D. M.|year=2001|title=Concept decompositions for large sparse text data using clustering|journal=Machine Learning|volume=42|issue=1|pages=143&ndash;175|doi=10.1023/a:1007612920971}}</ref>
* Hierarchical variants such as Bisecting ''k''-means,<ref>Steinbach, M., Karypis, G., & Kumar, V. (2000, August). A comparison of document clustering techniques. In KDD workshop on text mining (Vol. 400, No. 1, pp. 525-526).</ref> [[X-means clustering]]<ref>Pelleg, D., & Moore, A. W. (2000, June). X-means: Extending ''k''-means with Efficient Estimation of the Number of Clusters. In ICML (Vol. 1).</ref> and G-means clustering<ref>Hamerly, G., & Elkan, C. (2004). Learning the k in ''k''-means. Advances in neural information processing systems, 16, 281.</ref> [[Hierarchical clustering#Divisive clustering|repeatedly split clusters to build a hierarchy]], and can also try to automatically determine the optimal number of clusters in a dataset.
* [[Cluster analysis#Internal evaluation|Internal cluster evaluation]] measures such as [[Silhouette (clustering)|cluster silhouette]] can be helpful at [[Determining the number of clusters in a data set|determining the number of clusters]].
* Minkowski weighted ''k''-means automatically calculates cluster specific feature weights, supporting the intuitive idea that a feature may have different degrees of relevance at different features.<ref>{{Cite journal|last1=Amorim|first1=R.C.|last2=Mirkin|first2=B.|year=2012|title=Minkowski Metric, Feature Weighting and Anomalous Cluster Initialisation in ''k''-Means Clustering|journal=Pattern Recognition|volume=45|issue=3|pages=1061&ndash;1075|doi=10.1016/j.patcog.2011.08.012}}</ref> These weights can also be used to re-scale a given data set, increasing the likelihood of a cluster validity index to be optimized at the expected number of clusters.<ref>{{Cite journal|last1=Amorim|first1=R.C.|last2=Hennig|first2=C.|year=2015|title=Recovering the number of clusters in data sets with noise features using feature rescaling factors|journal=Information Sciences|volume=324|pages=126&ndash;145|arxiv=1602.06989|doi=10.1016/j.ins.2015.06.039}}</ref>
* Mini-batch ''k''-means: ''k''-means variation using "mini batch" samples for data sets that do not fit into memory.<ref>{{Cite conference|last=Sculley|first=David|date=2010|title=Web-scale ''k''-means clustering|url=http://dl.acm.org/citation.cfm?id=1772862|publisher=ACM|pages=1177–1178|accessdate=2016-12-21|booktitle=Proceedings of the 19th international conference on World Wide Web}}</ref>

=== Hartigan-Wong method ===
Hartigan and Wong's method<ref name="hartigan19792" /> provides a more sophisticated though more computationally expensive way to perform ''k''-means. It is still a heuristic method.

<math>\phi(S_j) </math>is the individual cost of <math>S_j</math> defined by <math>\sum_{x \in S_j} (x - \mu_j)^2</math>, with <math>\mu_j</math> the center of the cluster.

'''Assignment step:''' Hartigan and Wong's method starts by partitioning the points into random clusters <math>\{ S_j \}_{j \in \{1, \cdots k\}}</math>.

'''Update step''': Next it determines the <math>n,m \in \{1 \cdots k \}</math> and <math>x \in S_n</math> for which the following function reaches a minimum

<math>\Delta(m,n,x) =  \phi(S_n) + \phi(S_m) - \phi(S_n \backslash \{ x \} ) - \phi(S_m \cup \{ x \} )
</math>.

For the <math>x,n,m</math> that reach this minimum, <math>x</math>moves from the cluster <math>S_n</math> to the cluster <math>S_m</math>.

'''Termination''': The algorithm terminates once <math>\Delta(m,n,x)</math> is larger than zero for all <math>x,n,m</math>.

The algorithm can be sped up by immediately moving <math>x</math> from the cluster <math>S_n</math> to the cluster <math>S_m</math> as soon as an <math>x,n,m</math> have been found for which <math>\Delta(m,n,x) < 0</math>. This speed up can make the cost of the final result higher.

The function <math>\Delta</math> can be relatively efficiently evaluated by making use of the equality<ref name=":22">{{Cite web|url=http://proceedings.mlr.press/v9/telgarsky10a/telgarsky10a.pdf|title=Hartigan's Method: ''k''-means Clustering without Voronoi|last=Telgarsky|first=Matus|date=|website=|access-date=}}</ref>

<math>\Delta(x,n,m) = \frac{ \mid S_n \mid }{ \mid S_n \mid - 1} \cdot \lVert \mu_n - x \rVert^2  -
\frac{ \mid S_m \mid }{ \mid S_m \mid + 1} \cdot \lVert \mu_m - x \rVert^2</math>.

== Discussion ==
[[File:K-means_convergence_to_a_local_minimum.png|thumb|650x650px|A typical example of the ''k''-means convergence to a local minimum. In this example, the result of ''k''-means clustering (the right figure) contradicts the obvious cluster structure of the data set. The small circles are the data points, the four ray stars are the centroids (means). The initial configuration is on the left figure. The algorithm converges after five iterations presented on the figures, from the left to the right. The illustration was prepared with the Mirkes Java applet.<ref name="Mirkes20112">{{cite web|url=http://www.math.le.ac.uk/people/ag153/homepage/KmeansKmedoids/Kmeans_Kmedoids.html|title=K-means and ''k''-medoids applet.|last1=Mirkes|first1=E.M.|accessdate=2 January 2016}}</ref>]]
[[File:Iris_Flowers_Clustering_kMeans.svg|thumb|450x450px|''k''-means clustering result for the [[Iris flower data set]] and actual species visualized using [[Environment for DeveLoping KDD-Applications Supported by Index-Structures|ELKI]]. Cluster means are marked using larger, semi-transparent symbols.]]
[[File:ClusterAnalysis_Mouse.svg|thumb|450x450px|''k''-means clustering vs. [[EM clustering]] on an artificial dataset ("mouse"). The tendency of ''k''-means to produce equal-sized clusters leads to bad results here, while EM benefits from the Gaussian distributions with different radius present in the data set.]]
Three key features of ''k''-means that make it efficient are often regarded as its biggest drawbacks:

* [[Euclidean distance]] is used as a [[Metric (mathematics)|metric]] and [[variance]] is used as a measure of cluster scatter.
* The number of clusters ''k'' is an input parameter: an inappropriate choice of ''k'' may yield poor results. That is why, when performing ''k''-means, it is important to run diagnostic checks for [[Determining the number of clusters in a data set|determining the number of clusters in the data set]].
* Convergence to a local minimum may produce counterintuitive ("wrong") results (see example in Fig.).

A key limitation of ''k''-means is its cluster model. The concept is based on spherical clusters that are separable so that the mean converges towards the cluster center. The clusters are expected to be of similar size, so that the assignment to the nearest cluster center is the correct assignment. When for example applying ''k''-means with a value of <math>k=3</math> onto the well-known [[Iris flower data set]], the result often fails to separate the three [[Iris (plant)|Iris]] species contained in the data set. With <math>k=2</math>, the two visible clusters (one containing two species) will be discovered, whereas with <math>k=3</math> one of the two clusters will be split into two even parts. In fact, <math>k=2</math> is more appropriate for this data set, despite the data set's containing 3 ''classes''. As with any other clustering algorithm, the ''k''-means result makes assumptions that the data satisfy certain criteria. It works well on some data sets, and fails on others.

The result of ''k''-means can be seen as the [[Voronoi diagram|Voronoi cells]] of the cluster means. Since data is split halfway between cluster means, this can lead to suboptimal splits as can be seen in the "mouse" example. The Gaussian models used by the [[Expectation-maximization algorithm]] (arguably a generalization of ''k''-means) are more flexible by having both variances and covariances. The EM result is thus able to accommodate clusters of variable size much better than ''k''-means as well as correlated clusters (not in this example). ''K''-means is closely related to nonparametric [[Bayesian inference|Bayesian modeling]].<ref>{{Cite book|last=Kulis|first=Brian|last2=Jordan|first2=Michael I.|date=2012-06-26|title=Revisiting ''k''-means: new algorithms via Bayesian nonparametrics|url=https://icml.cc/2012/papers/291.pdf|journal=ICML|publisher=|volume=|pages=1131–1138|isbn=9781450312851|via=}}</ref>

== Applications ==
''k''-means clustering is rather easy to apply to even large data sets, particularly when using heuristics such as [[Lloyd's algorithm]]. It has been successfully used in [[market segmentation]], [[computer vision]], and [[astronomy]] among many other domains. It often is used as a preprocessing step for other algorithms, for example to find a starting configuration.

===Vector quantization===
{{Main|Vector quantization}}
[[File:Rosa_Gold_Glow_2_small_noblue.png|right|frame|Two-channel (for illustration purposes -- red and green only) color image.]]
[[File:Rosa_Gold_Glow_2_small_noblue_color_space.png|right|thumb|250x250px|Vector quantization of colors present in the image above into Voronoi cells using ''k''-means.]]
''k''-means originates from signal processing, and still finds use in this domain. For example, in [[computer graphics]], [[color quantization]] is the task of reducing the [[color palette]] of an image to a fixed number of colors ''k''. The ''k''-means algorithm can easily be used for this task and produces competitive results. A use case for this approach is [[image segmentation]]. Other uses of vector quantization include [[Sampling (statistics)|non-random sampling]], as ''k''-means can easily be used to choose ''k'' different but prototypical objects from a large data set for further analysis.

===Cluster analysis===
{{Main|Cluster analysis}}In cluster analysis, the ''k''-means algorithm can be used to partition the input data set into ''k'' partitions (clusters).

However, the pure ''k''-means algorithm is not very flexible, and as such is of limited use (except for when vector quantization as above is actually the desired use case). In particular, the parameter ''k'' is known to be hard to choose (as discussed above) when not given by external constraints. Another limitation is that it cannot be used with arbitrary distance functions or on non-numerical data. For these use cases, many other algorithms are superior.

=== Feature learning ===
''k''-means clustering has been used as a [[feature learning]] (or [[dictionary learning]]) step, in either ([[Semi-supervised learning|semi-]])[[supervised learning]] or [[unsupervised learning]].<ref name="Coates20122">{{cite encyclopedia|year=2012|title=Learning feature representations with ''k''-means|encyclopedia=Neural Networks: Tricks of the Trade|publisher=Springer|url=https://cs.stanford.edu/~acoates/papers/coatesng_nntot2012.pdf|last2=Ng|first2=Andrew Y.|last1=Coates|first1=Adam|editors=G. Montavon, G. B. Orr, K.-R. Müller}}</ref> The basic approach is first to train a ''k''-means clustering representation, using the input training data (which need not be labelled). Then, to project any input datum into the new feature space, an "encoding" function, such as the thresholded matrix-product of the datum with the centroid locations, computes the distance from the datum to each centroid, or simply an indicator function for the nearest centroid,<ref name="Coates20122" /><ref>{{cite conference|last1=Csurka|first1=Gabriella|last2=Dance|first2=Christopher C.|last3=Fan|first3=Lixin|last4=Willamowski|first4=Jutta|last5=Bray|first5=Cédric|year=2004|title=Visual categorization with bags of keypoints|url=http://www.cs.cmu.edu/~efros/courses/LBMV07/Papers/csurka-eccv-04.pdf|conference=ECCV Workshop on Statistical Learning in Computer Vision}}</ref> or some smooth transformation of the distance.<ref name="coates20112">{{cite conference|last1=Coates|first1=Adam|last2=Lee|first2=Honglak|last3=Ng|first3=Andrew Y.|year=2011|title=An analysis of single-layer networks in unsupervised feature learning|url=http://www.stanford.edu/~acoates/papers/coatesleeng_aistats_2011.pdf|deadurl=yes|conference=International Conference on Artificial Intelligence and Statistics (AISTATS)|archiveurl=https://web.archive.org/web/20130510120705/http://www.stanford.edu/~acoates/papers/coatesleeng_aistats_2011.pdf|archivedate=2013-05-10|df=}}</ref> Alternatively, transforming the sample-cluster distance through a [[Radial basis function|Gaussian RBF]], obtains the hidden layer of a [[radial basis function network]].<ref name="schwenker2">{{cite journal|last1=Schwenker|first1=Friedhelm|last2=Kestler|first2=Hans A.|last3=Palm|first3=Günther|year=2001|title=Three learning phases for radial-basis-function networks|journal=Neural Networks|volume=14|issue=4–5|pages=439–458|citeseerx=10.1.1.109.312|doi=10.1016/s0893-6080(01)00027-2}}</ref>

This use of ''k''-means has been successfully combined with simple, [[Linear classifier|linear classifiers]] for semi-supervised learning in [[Natural language processing|NLP]] (specifically for [[named entity recognition]])<ref>{{cite conference|last1=Lin|first1=Dekang|last2=Wu|first2=Xiaoyun|year=2009|title=Phrase clustering for discriminative learning|url=http://www.aclweb.org/anthology/P/P09/P09-1116.pdf|conference=Annual Meeting of the [[Association for Computational Linguistics|ACL]] and IJCNLP|pages=1030–1038}}</ref> and in [[computer vision]]. On an object recognition task, it was found to exhibit comparable performance with more sophisticated feature learning approaches such as [[Autoencoder|autoencoders]] and [[Restricted Boltzmann machine|restricted Boltzmann machines]].<ref name="coates20112" /> However, it generally requires more data, for equivalent performance, because each data point only contributes to one "feature".<ref name="Coates20122" />

== Relation to other algorithms ==
=== Gaussian mixture model ===
''k''-means clustering, and its associated [[Expectation–maximization algorithm|expectation-maximization algorithm]], is a special case of a [[Mixture model|Gaussian mixture model]], specifically, the limit of taking all covariances as diagonal, equal and small. It is often easy to generalize a ''k''-means problem into a Gaussian mixture model.<ref>{{Cite book|title=Numerical Recipes: The Art of Scientific Computing|last1=Press|first1=WH|last2=Teukolsky|first2=SA|last3=Vetterling|first3=WT|last4=Flannery|first4=BP|publisher=Cambridge University Press|year=2007|isbn=978-0-521-88068-8|edition=3rd|location=New York|chapter=Section 16.1. Gaussian Mixture Models and ''k''-Means Clustering|chapter-url=http://apps.nrbook.com/empanel/index.html#pg=842}}</ref> Another generalization of the ''k''-means algorithm is the [[K-SVD]] algorithm, which estimates data points as a sparse linear combination of "codebook vectors". ''k''-means corresponds to the special case of using a single codebook vector, with a weight of 1.<ref>{{Cite journal|last1=Aharon|first1=Michal|last2=Elad|first2=Michael|last3=Bruckstein|first3=Alfred|year=2006|title=K-SVD: An Algorithm for Designing Overcomplete Dictionaries for Sparse Representation|url=http://intranet.daiict.ac.in/~ajit_r/IT530/KSVD_IEEETSP.pdf|deadurl=yes|journal=IEEE Transactions on Signal Processing|volume=54|issue=11|pages=4311|bibcode=2006ITSP...54.4311A|doi=10.1109/TSP.2006.881199|archiveurl=https://web.archive.org/web/20130620125943/http://intranet.daiict.ac.in/~ajit_r/IT530/KSVD_IEEETSP.pdf|archivedate=2013-06-20|df=}}</ref>

=== Principal component analysis ===
The relaxed solution of {{math|<var>k</var>}}-means clustering, specified by the cluster indicators, is given by [[principal component analysis]] (PCA).<ref>{{cite journal|authors=H. Zha, C. Ding, M. Gu, X. He and H.D. Simon|date=Dec 2001|title=Spectral Relaxation for ''k''-means Clustering|url=http://ranger.uta.edu/~chqding/papers/Zha-Kmeans.pdf|journal=Neural Information Processing Systems Vol.14 (NIPS 2001)|pages=1057–1064}}</ref><ref>{{cite journal|authors=Chris Ding and Xiaofeng He|date=July 2004|title=K-means Clustering via Principal Component Analysis|url=http://ranger.uta.edu/~chqding/papers/KmeansPCA1.pdf|pages=225–232|journal=Proc. Of Int'l Conf. Machine Learning (ICML 2004)}}</ref> The PCA subspace spanned by the principal directions is identical to the cluster centroid subspace. The intuition is that ''k''-means describe spherically shaped (ball-like) clusters. If the data has 2 clusters, the line connecting the two centroids is the best 1-dimensional projection direction, which is also the first PCA direction. Cutting the line at the center of mass separates the clusters (this is the continuous relaxation of the discrete cluster indicator). If the data have three clusters, the 2-dimensional plane spanned by three cluster centroids is the best 2-D projection. This plane is also defined by the first two PCA dimensions. Well-separated clusters are effectively modeled by ball-shaped clusters and thus discovered by ''k''-means. Non-ball-shaped clusters are hard to separate when they are close. For example, two half-moon shaped clusters intertwined in space do not separate well when projected onto PCA subspace. ''k''-means should not be expected to do well on this data.<ref>{{cite journal|last=Drineas|first=P.|author2=A. Frieze|author3=R. Kannan|author4=S. Vempala|author5=V. Vinay|year=2004|title=Clustering large graphs via the singular value decomposition|url=http://www.cc.gatech.edu/~vempala/papers/dfkvv.pdf|journal=Machine Learning|volume=56|issue=1–3|pages=9–33|doi=10.1023/b:mach.0000033113.59016.96|id=|accessdate=2012-08-02}}</ref> It is straightforward to produce counterexamples to the statement that the cluster centroid subspace is spanned by the principal directions.<ref>{{cite arXiv|eprint=1410.6801|class=cs.DS|first=M.|last=Cohen|author2=S. Elder|title=Dimensionality reduction for ''k''-means clustering and low rank approximation (Appendix B)|year=2014|author3=C. Musco|author4=C. Musco|author5=M. Persu}}</ref>

=== Mean shift clustering ===
Basic [[mean shift]] clustering algorithms maintain a set of data points the same size as the input data set. Initially, this set is copied from the input set. Then this set is iteratively replaced by the mean of those points in the set that are within a given distance of that point. By contrast, ''k''-means restricts this updated set to ''k'' points usually much less than the number of points in the input data set, and replaces each point in this set by the mean of all points in the ''input set'' that are closer to that point than any other (e.g. within the Voronoi partition of each updating point). A mean shift algorithm that is similar then to ''k''-means, called ''likelihood mean shift'', replaces the set of points undergoing replacement by the mean of all points in the input set that are within a given distance of the changing set.<ref name="Little20112">{{cite journal|last=Little|first=M.A.|author2=Jones, N.S.|year=2011|title=Generalized Methods and Solvers for Piecewise Constant Signals: Part I|url=http://www.maxlittle.net/publications/pwc_filtering_arxiv.pdf|journal=[[Proceedings of the Royal Society A]]|volume=467|issue=2135|pages=3088–3114|bibcode=2011RSPSA.467.3088L|doi=10.1098/rspa.2010.0671|pmid=22003312}}</ref> One of the advantages of mean shift over ''k''-means is that the number of clusters is not pre-specified, because mean shift is likely to find only a few clusters if only a small number exist. However, mean shift can be much slower than ''k''-means, and still requires selection of a bandwidth parameter. Mean shift has soft variants.

=== Independent component analysis ===
Under sparsity assumptions and when input data is pre-processed with the [[whitening transformation]], ''k''-means produces the solution to the linear [[independent component analysis]] (ICA) task. This aids in explaining the successful application of ''k''-means to [[K-means clustering#Feature learning|feature learning]].<ref>{{cite journal|authors=Alon Vinnikov and Shai Shalev-Shwartz|year=2014|title=K-means Recovers ICA Filters when Independent Components are Sparse|url=http://www.cs.huji.ac.il/~shais/papers/KmeansICA_ICML2014.pdf|journal=Proc. Of Int'l Conf. Machine Learning (ICML 2014)}}</ref>

=== Bilateral filtering ===
''k''-means implicitly assumes that the ordering of the input data set does not matter. The [[bilateral filter]] is similar to ''k''-means and [[mean shift]] in that it maintains a set of data points that are iteratively replaced by means. However, the bilateral filter restricts the calculation of the (kernel weighted) mean to include only points that are close in the ordering of the input data.<ref name="Little20112" /> This makes it applicable to problems such as image denoising, where the spatial arrangement of pixels in an image is of critical importance.

==Similar problems==
The set of squared error minimizing cluster functions also includes the [[K-medoids|{{math|<var>k</var>}}-medoids]] algorithm, an approach which forces the center point of each cluster to be one of the actual points, i.e., it uses [[medoids]] in place of [[centroids]].

== Software implementations ==
Different implementations of the algorithm exhibit performance differences, with the fastest on a test data set finishing in 10 seconds, the slowest taking 25,988 seconds (~7 hours).<ref name=":12" /> The differences can be attributed to implementation quality, language and compiler differences, different termination criteria and precision levels, and the use of indexes for acceleration.

=== Free Software/Open Source ===
The following implementations are available under [[Free and open-source software|Free/Open Source Software]] licenses, with publicly available source code.

* [[Accord.NET]] contains C# implementations for ''k''-means, ''k''-means++ and ''k''-modes.
* [[ALGLIB]] contains parallelized C++ and C# implementations for ''k''-means and ''k''-means++.
* [[CrimeStat]] implements two spatial ''k''-means algorithms, one of which allows the user to define the starting locations.
* [[ELKI]] contains ''k''-means (with Lloyd and MacQueen iteration, along with different initializations such as ''k''-means++ initialization) and various more advanced clustering algorithms.
* [[Julia language|Julia]] contains a ''k''-means implementation in the JuliaStats Clustering package.
* [[KNIME]] contains nodes for ''k''-means and ''k''-medoids.
* [[Apache Mahout|Mahout]] contains a [[MapReduce]] based ''k''-means.
* [[mlpack]] contains a C++ implementation of ''k''-means.
* [[GNU Octave|Octave]] contains ''k''-means.
* [[OpenCV]] contains a ''k''-means implementation.
* [[Orange (software)|Orange]] includes a component for ''k''-means clustering with automatic selection of ''k'' and cluster silhouette scoring.
* [[PSPP]] contains ''k''-means, The QUICK CLUSTER command performs ''k''-means clustering on the dataset.
* [[R (programming language)|R]] contains three ''k''-means variations.
* [[SciPy]] and [[scikit-learn]] contain multiple ''k''-means implementations.
* [[Apache Spark|Spark]] MLlib implements a distributed ''k''-means algorithm.
* [[Torch (machine learning)|Torch]] contains an ''unsup'' package that provides ''k''-means clustering.
* [[Weka (machine learning)|Weka]] contains ''k''-means and ''x''-means.

=== Proprietary ===
The following implementations are available under [[Proprietary software|proprietary]] license terms, and may not have publicly available source code.

* [[Ayasdi]]
* [[MATLAB]]
* [[Mathematica]]
* [[RapidMiner]]
* [[SAP HANA]]
* [[SAS System|SAS]]
* [[SPSS]]
* [[Stata]]

==See also==

* [[BFR algorithm]]
* [[Centroidal Voronoi tessellation]]
* [[Head/tail Breaks]]
* [[K-means++]]
* [[k q-flats]]
* [[Linde–Buzo–Gray algorithm]]
* [[Self-organizing map]]

==References==
{{Reflist|2}}{{DISPLAYTITLE:''k''-means clustering}}
{{DEFAULTSORT:K-Means Clustering}}
[[Category:Cluster analysis algorithms]]
<br />